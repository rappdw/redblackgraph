/* This file is autogenerated by generate_sparsetools.py
 * Do not edit manually or check into VCS.
 */

static int get_thunk_case(int I_typenum, int T_typenum)
{
        if (0) {}
        else if (I_typenum == NPY_INT32) {
            if (T_typenum == -1) { return 0; }
            else if (T_typenum == NPY_BYTE) { return 1; }
            else if (T_typenum == NPY_SHORT) { return 2; }
            else if (T_typenum == NPY_INT) { return 3; }
            else if (T_typenum == NPY_LONG) { return 4; }
            else if (T_typenum == NPY_LONGLONG) { return 5; }
        }
        else if (I_typenum == NPY_INT64) {
            if (T_typenum == -1) { return 6; }
            else if (T_typenum == NPY_BYTE) { return 7; }
            else if (T_typenum == NPY_SHORT) { return 8; }
            else if (T_typenum == NPY_INT) { return 9; }
            else if (T_typenum == NPY_LONG) { return 10; }
            else if (T_typenum == NPY_LONGLONG) { return 11; }
        };
    return -1;
}

static Py_ssize_t rbm_matmat_pass1_thunk(int I_typenum, int T_typenum, void **a)
{
    int j = get_thunk_case(I_typenum, T_typenum);
    switch (j) {
        case 0:
            (void)rbm_matmat_pass1<npy_int32>(*(const npy_int32*)a[0], *(const npy_int32*)a[1], (const npy_int32*)a[2], (const npy_int32*)a[3], (const npy_int32*)a[4], (const npy_int32*)a[5], (npy_int32*)a[6]);
            return 0;
        case 6:
            (void)rbm_matmat_pass1<npy_int64>(*(const npy_int64*)a[0], *(const npy_int64*)a[1], (const npy_int64*)a[2], (const npy_int64*)a[3], (const npy_int64*)a[4], (const npy_int64*)a[5], (npy_int64*)a[6]);
            return 0;
    default:
        throw std::runtime_error("internal error: invalid argument typenums");
    }
}

static Py_ssize_t rbm_matmat_pass2_thunk(int I_typenum, int T_typenum, void **a)
{
    int j = get_thunk_case(I_typenum, T_typenum);
    switch (j) {
        case 1:
            (void)rbm_matmat_pass2<npy_int32,npy_byte>(*(const npy_int32*)a[0], *(const npy_int32*)a[1], (const npy_int32*)a[2], (const npy_int32*)a[3], (const npy_byte*)a[4], (const npy_int32*)a[5], (const npy_int32*)a[6], (const npy_byte*)a[7], (npy_int32*)a[8], (npy_int32*)a[9], (npy_byte*)a[10]);
            return 0;
        case 2:
            (void)rbm_matmat_pass2<npy_int32,npy_short>(*(const npy_int32*)a[0], *(const npy_int32*)a[1], (const npy_int32*)a[2], (const npy_int32*)a[3], (const npy_short*)a[4], (const npy_int32*)a[5], (const npy_int32*)a[6], (const npy_short*)a[7], (npy_int32*)a[8], (npy_int32*)a[9], (npy_short*)a[10]);
            return 0;
        case 3:
            (void)rbm_matmat_pass2<npy_int32,npy_int>(*(const npy_int32*)a[0], *(const npy_int32*)a[1], (const npy_int32*)a[2], (const npy_int32*)a[3], (const npy_int*)a[4], (const npy_int32*)a[5], (const npy_int32*)a[6], (const npy_int*)a[7], (npy_int32*)a[8], (npy_int32*)a[9], (npy_int*)a[10]);
            return 0;
        case 4:
            (void)rbm_matmat_pass2<npy_int32,npy_long>(*(const npy_int32*)a[0], *(const npy_int32*)a[1], (const npy_int32*)a[2], (const npy_int32*)a[3], (const npy_long*)a[4], (const npy_int32*)a[5], (const npy_int32*)a[6], (const npy_long*)a[7], (npy_int32*)a[8], (npy_int32*)a[9], (npy_long*)a[10]);
            return 0;
        case 5:
            (void)rbm_matmat_pass2<npy_int32,npy_longlong>(*(const npy_int32*)a[0], *(const npy_int32*)a[1], (const npy_int32*)a[2], (const npy_int32*)a[3], (const npy_longlong*)a[4], (const npy_int32*)a[5], (const npy_int32*)a[6], (const npy_longlong*)a[7], (npy_int32*)a[8], (npy_int32*)a[9], (npy_longlong*)a[10]);
            return 0;
        case 7:
            (void)rbm_matmat_pass2<npy_int64,npy_byte>(*(const npy_int64*)a[0], *(const npy_int64*)a[1], (const npy_int64*)a[2], (const npy_int64*)a[3], (const npy_byte*)a[4], (const npy_int64*)a[5], (const npy_int64*)a[6], (const npy_byte*)a[7], (npy_int64*)a[8], (npy_int64*)a[9], (npy_byte*)a[10]);
            return 0;
        case 8:
            (void)rbm_matmat_pass2<npy_int64,npy_short>(*(const npy_int64*)a[0], *(const npy_int64*)a[1], (const npy_int64*)a[2], (const npy_int64*)a[3], (const npy_short*)a[4], (const npy_int64*)a[5], (const npy_int64*)a[6], (const npy_short*)a[7], (npy_int64*)a[8], (npy_int64*)a[9], (npy_short*)a[10]);
            return 0;
        case 9:
            (void)rbm_matmat_pass2<npy_int64,npy_int>(*(const npy_int64*)a[0], *(const npy_int64*)a[1], (const npy_int64*)a[2], (const npy_int64*)a[3], (const npy_int*)a[4], (const npy_int64*)a[5], (const npy_int64*)a[6], (const npy_int*)a[7], (npy_int64*)a[8], (npy_int64*)a[9], (npy_int*)a[10]);
            return 0;
        case 10:
            (void)rbm_matmat_pass2<npy_int64,npy_long>(*(const npy_int64*)a[0], *(const npy_int64*)a[1], (const npy_int64*)a[2], (const npy_int64*)a[3], (const npy_long*)a[4], (const npy_int64*)a[5], (const npy_int64*)a[6], (const npy_long*)a[7], (npy_int64*)a[8], (npy_int64*)a[9], (npy_long*)a[10]);
            return 0;
        case 11:
            (void)rbm_matmat_pass2<npy_int64,npy_longlong>(*(const npy_int64*)a[0], *(const npy_int64*)a[1], (const npy_int64*)a[2], (const npy_int64*)a[3], (const npy_longlong*)a[4], (const npy_int64*)a[5], (const npy_int64*)a[6], (const npy_longlong*)a[7], (npy_int64*)a[8], (npy_int64*)a[9], (npy_longlong*)a[10]);
            return 0;
    default:
        throw std::runtime_error("internal error: invalid argument typenums");
    }
}

NPY_VISIBILITY_HIDDEN PyObject *
rbm_matmat_pass1_method(PyObject *self, PyObject *args)
{
    return call_thunk('v', "iiIIII*I", rbm_matmat_pass1_thunk, args);
}

NPY_VISIBILITY_HIDDEN PyObject *
rbm_matmat_pass2_method(PyObject *self, PyObject *args)
{
    return call_thunk('v', "iiIITIIT*I*I*T", rbm_matmat_pass2_thunk, args);
}
