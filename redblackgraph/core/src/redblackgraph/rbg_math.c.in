#include <Python.h>
#include <stdlib.h>

#define NO_IMPORT_ARRAY
#define PY_ARRAY_UNIQUE_SYMBOL RBG_ARRAY_API

#include <numpy/ndarraytypes.h>
#include <numpy/arrayscalars.h>

#include "rbg_math.h"

{{py:
# Type definitions for AVOS operations
# Each tuple is (name, type, utype)
type_defs = [
    ('byte', 'npy_byte', 'npy_ubyte'),
    ('ubyte', 'npy_ubyte', 'npy_ubyte'),
    ('short', 'npy_short', 'npy_ushort'),
    ('ushort', 'npy_ushort', 'npy_ushort'),
    ('int', 'npy_int', 'npy_uint'),
    ('uint', 'npy_uint', 'npy_uint'),
    ('long', 'npy_long', 'npy_ulong'),
    ('ulong', 'npy_ulong', 'npy_ulong'),
    ('longlong', 'npy_longlong', 'npy_ulonglong'),
    ('ulonglong', 'npy_ulonglong', 'npy_ulonglong'),
]
}}

{{for name, type, utype in type_defs}}
{{type}} {{name}}_avos_sum({{type}} a, {{type}} b)
{
    if (a == 0 || ({{utype}})(~b) == 0) return b;
    if (b == 0 || ({{utype}})(~a) == 0) return a;
    if ((({{utype}})a) < (({{utype}})b)) return a;
    return b;
}

short {{name}}_MSB({{type}} x)
{
    if (({{utype}})~x == 0) return 0;
    short targetlevel = 0;
    while (x >>= 1) {
        targetlevel += 1;
    }
    return targetlevel;
}

{{utype}} {{name}}_avos_product({{type}} lhs, {{type}} rhs)
{
    {{utype}} x = ({{utype}})lhs;
    {{utype}} y = ({{utype}})rhs;

    // The zero property of the avos product
    if (x == 0 || y == 0) {
        return 0;
    }
    
    // Identity ⊗ Identity special cases (must come before other checks)
    // Same-gender self-loops
    if (lhs == ({{type}})-1 && rhs == ({{type}})-1) {
        return x;  // RED_ONE ⊗ RED_ONE = RED_ONE (male self-loop)
    }
    if (lhs == 1 && rhs == 1) {
        return 1;  // BLACK_ONE ⊗ BLACK_ONE = BLACK_ONE (female self-loop)
    }
    
    // Cross-gender identity cases (RED_ONE is even/male, BLACK_ONE is odd/female)
    if (lhs == ({{type}})-1 && rhs == 1) {
        return 0;  // RED_ONE ⊗ BLACK_ONE: male's female self is undefined
    }
    if (lhs == 1 && rhs == ({{type}})-1) {
        return 0;  // BLACK_ONE ⊗ RED_ONE: female's male self is undefined
    }
    
    // Identity on LEFT (lhs): Just a starting point marker, treat as 1 for bit-shift
    // Example: RED_ONE ⊗ 3 = "male-me's mother" = bit_shift(1, 3) = 3
    if (lhs == ({{type}})-1) {
        x = 1;  // Treat RED_ONE as 1 for composition
    }
    
    // Identity on RIGHT (rhs): Acts as gender/parity filter
    // Example: 3 ⊗ RED_ONE = "mother's male self" = 0 (mother is odd/female)
    //          3 ⊗ BLACK_ONE = "mother's female self" = 3 (mother is odd/female)
    
    // When rhs is RED_ONE (-1): Filters for even values only
    if (rhs == ({{type}})-1) {
        if (lhs & 1) {  // lhs is odd (use original lhs, not converted x)
            return 0;  // Odd values have no male self
        } else {
            return x;  // Even values' male self is themselves
        }
    }
    
    // When rhs is BLACK_ONE (1): Filters for odd values only
    if (rhs == 1) {
        if (lhs & 1) {  // lhs is odd
            return x;  // Odd values' female self is themselves
        } else {
            return 0;  // Even values have no female self
        }
    }

    short bit_position = {{name}}_MSB(y);
    short result_size = {{name}}_MSB(x) + bit_position;
    if (result_size >= (short)(sizeof(x) * 8)) {
        // Overflow Error
        PyErr_Format(PyExc_OverflowError,
                         "Avos product of %lu and %lu, results in an overflow. (Result size would require %u bits; Type provides %u bits)", \
                         lhs, rhs, result_size + 1, (short)(sizeof(x) * 8)
                         );
    }
    {{utype}} result = ((y & ((({{utype}})1 << bit_position) - 1)) | (x << bit_position));
    if (result == ({{utype}})-1) {
        // Overflow Error
        PyErr_Format(PyExc_OverflowError,
        "Avos product of %lu and %lu, results in an overflow. Result of avos product collides with 'red' 1 (-1).", \
                                 lhs, rhs
        );
    }
    return result;
}

{{endfor}}
