/* -*- c -*- */

/*
 *****************************************************************************
 **                            INCLUDES                                     **
 *****************************************************************************
 */
#include <stdio.h>
#include <Python.h>
#include <math.h>

#define NO_IMPORT_ARRAY
#define PY_ARRAY_UNIQUE_SYMBOL RBG_ARRAY_API

#include <numpy/noprefix.h>
#include <numpy/ndarraytypes.h>
#include <numpy/ndarrayobject.h>
#include <numpy/arrayscalars.h>
#include <numpy/ufuncobject.h>

#include "redblack.h"
#include "rbg_math.h"

/*
 *****************************************************************************
 **                             UFUNC LOOPS                                 **
 *****************************************************************************
 */

char *warshall_signature = "(m,m)->(m,m),()";

{{py:
# Type definitions for Warshall algorithm
# Each tuple is (name, type, utype, format, type_num)
type_defs = [
    ('byte', 'npy_byte', 'npy_ubyte', 'u', 'NPY_BYTE'),
    ('ubyte', 'npy_ubyte', 'npy_ubyte', 'u', 'NPY_UBYTE'),
    ('short', 'npy_short', 'npy_ushort', 'u', 'NPY_SHORT'),
    ('ushort', 'npy_ushort', 'npy_ushort', 'u', 'NPY_USHORT'),
    ('int', 'npy_int', 'npy_uint', 'u', 'NPY_INT'),
    ('uint', 'npy_uint', 'npy_uint', 'u', 'NPY_UINT'),
    ('long', 'npy_long', 'npy_ulong', 'lu', 'NPY_LONG'),
    ('ulong', 'npy_ulong', 'npy_ulong', 'lu', 'NPY_ULONG'),
    ('longlong', 'npy_longlong', 'npy_ulonglong', 'llu', 'NPY_LONGLONG'),
    ('ulonglong', 'npy_ulonglong', 'npy_ulonglong', 'llu', 'NPY_ULONGLONG'),
]
}}

{{for name, type, utype, format, type_num in type_defs}}
static void
{{name}}_warshall(char **args, const npy_intp *dimensions, const npy_intp *steps)
{
    /* pointers to data for input and output arrays */
    char *ipR1 = args[1]; // first pointer to R
    char *ipR2 = args[1]; // second pointer to R
    char *op = args[1];
    {{type}} product;

    /* lengths of core dimensions */
    npy_intp dn = dimensions[0];

    /* striding over core dimensions */
    npy_intp isR_i = steps[0];
    npy_intp isR_j = steps[1];
    npy_intp os_i = steps[2];
    npy_intp os_j = steps[3];

    /* core dimensions counters */
    npy_intp i, j, k;

    /* diameter holder */
    {{type}} diameter = 0;

    /* Step 1, copy input matrix to output matrix */
    memcpy(args[1], args[0], dn * isR_i);

    /* Step 2, run Floyd-Warshall over the output matrix */
    for (k = 0; k < dn; k++) {
        for (i = 0; i < dn; i++) {
            for (j = 0; j < dn; j++) {
                product = {{name}}_avos_product((*({{type}} *)ipR1), (*({{type}} *)ipR2));
                if (i == j && !(product == ({{type}})-1 || product == 0 || product == 1)) {
                    PyErr_Format(PyExc_ValueError,
                                     "Error: cycle detected! Vertex %ld has a path to itself. A(%ld,%ld)=%{{format}}, A(%ld,%ld)=%{{format}}", \
                                     i, i, k, ({{utype}})(*({{type}} *)ipR1), k, j, ({{utype}})(*({{type}} *)ipR2)
                                     );
                }
                *({{type}} *)op = {{name}}_avos_sum(*({{type}} *)op, product);
                if (({{utype}})(~*({{type}} *)op) != 0 && *({{type}} *)op > diameter) diameter = *({{type}} *)op;

                // advance column of output, advance column of R2
                ipR2 += isR_j;
                op  +=  os_j;
            }
            // advance to next row and first column of output, advance row of R1, reset R2 to first column
            op -= os_j * dn;
            op += os_i;
            ipR1 += isR_i;
            ipR2 -= isR_j * dn;
        }
        // reset output, reset R1 to first row and set to column k, advance to next row and first column of R2
        op = args[1];
        ipR1 = args[1] + (k + 1) * isR_j;
        ipR2 += isR_i;
    }
    *(npy_intp *)args[2] = {{name}}_MSB(diameter);
}

static void
{{name}}_gufunc_warshall(char **args, const npy_intp *dimensions, const npy_intp *steps, void *NPY_UNUSED(func))
{
    /* outer dimensions counter */
    npy_intp N_;

    /* length of flattened outer dimensions */
    npy_intp dN = dimensions[0];

    /* striding over flattened outer dimensions for input and output arrays */
    // (m,m)->(m,m),()
    npy_intp s0 = steps[0];
    npy_intp s1 = steps[1];
    // npy_intp s2 = steps[2];

    /*
     * loop through outer dimensions, performing matrix multiply on
     * core dimensions for each loop
     */
    for (N_ = 0; N_ < dN; N_++, args[0] += s0, args[1] += s1) {
        {{name}}_warshall(args, dimensions+1, steps+3);
    }
}

{{endfor}}

PyUFuncGenericFunction warshall_functions[] = {
{{for name, type, utype, format, type_num in type_defs}}
    &{{name}}_gufunc_warshall,
{{endfor}}
};
void *warshall_data[] = {
{{for name, type, utype, format, type_num in type_defs}}
    (void *)NULL,
{{endfor}}
};

char warshall_signatures[] = {
{{for name, type, utype, format, type_num in type_defs}}
    {{type_num}}, {{type_num}}, NPY_INT,
{{endfor}}
};


